# AI

Solving code implementation based on a given input and an expected output. This is similar to test writing where a test provides the given in and an expected output and then compares them.

## Based on the given input 
- system learns from raw data passing through functions as arguments and the result return value from those functions
- Possible functions to use are all functions in the system that match the given input parameters
- A function is broken down into...
- 1) core logic (stripped of names and values)
- 2) names (specific names given to things like variables, parameters, functions and properties)
- 3) values (specific values like strings, numbers, booleans, etc)
- Functions are stored based on the above breakdown. A change in value or name does not represent a different function)
- Specific value solutions can be determined based on identifying and using the correct reverse solving function. For instance if the given value is 200 and the expected output is 2 we can determine that the division function is the likely path and backward calculate the hard coded value of 100 as the divisor. The solution for generating that number is calculated by the input value / the output value.
- Identifying the solver function to use is similar to how we identify the correct logic function. Use a neural net at the value point in the function to map to possible solver functions. 
- Logic implementation solving is based on taking the different starting functions whose signatures match and then tweaking the internal references to other functions to get the logic to produce the expected return shape.
- The “reference” connections can only map to so many other functions that actually work and don’t cause errors. 
- The references are the points that are mapped by neural nets. Since there are multiple possibilities and the system is meant to figure out the one that works for the given inputs and outputs. 
- The possible shapes and connections between references are the available moves on the chess board. 
- The possibilities can be generated on the fly by calculating them. They can also be generated by analyzing existing code to map possible patterns. 
- The possibilities are indeed infinite but at some point the probability of being a branch that is a possible solution reduces to far that the path should no longer be explored. 
- The probabilities of which path to take are determined by the neural net.
- The possible paths can be generated on demand when needed but the likely paths should always be explored first
- Naming of identifiers is more of an NLP problem. Names of things can be partially mapped by looking at existing code and seeing what names were used for things. Names should also be derived from the data schema level. An ontology of schemas should be generated and stored. Then we can begin to derive the functions names based on the input and output schemas.
- Neural nets should be mapped based on types as inputs
- The result of these neural nets is that they will have a lot of input Enron’s and a lot of output neurons
- The scale of those neural nets should be managed by keeping the number of connection points between the neurons low. When a solution is first found we identify which inputs were 1 and which outputs were 1. We then connect the inputs to the outputs and train the network based on the values passed through the function.
- Also, we can have large neural nets where we only load part of the network based on which neurons are connected to each other. For instance, in a network with lots of inputs and lots of outputs. We determine which inputs will be 1 and then load the neurons that will be 1 along with the neurons they are connected to. Thereby only loading a portion of the full network
- Step 1) pass the input through a type identifier
- Identify the functions that map to the given type signature. 
  - This is done using two approaches. 
  1) The first is a neural net where each input neuron is each possible type and the output is the functions that match to that type
  2) the second is a brute force approach by simple loading all functions that match the given type starting with the most specific first. 
     *Note* Type identification is based on a tree structure. Types that are
     super types must match all of their subtypes. For instance. Object is a top
     level type. A subtype of "User" will always match Object. All Users are
     Objects, not all Objects are Users.

